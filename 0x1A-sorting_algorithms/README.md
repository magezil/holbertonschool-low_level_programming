# 0x1A-sorting_algorithms

## Sorting algorithms & Big O
### 0-bubble_sort.c, 0-O
* Function implements the bubble sort algorithm on an array of numbers
* Best case - list already sorted: O(n)
* Average case: O(n^2)
* Worst case - list reverse sorted: O(n^2)

### 1-insertion_sort_list.c, 1-O
* Function implements insertion sort algorithm on a linked list
* Best case - list already sorted: O(n)
* Average case: O(n^2)
* Worst case - list reverse sorted: O(n^2)

### 2-selection_sort.c, 2-O
* Function implements selection sort algorithm on an array of numbers
* Best case: O(n^2)
* Average case: O(n^2)
* Worst case: O(n^2)

### 3-quick_sort.c, 3-O
* Function implements quick sort algorithm on an array of numbers (Lomuto partition scheme)
* Best case: O(nlog(n))
* Average case: O(nlog(n))
* Worst case(already sorted list): O(n^2)

### 4-O through 14-O
* Big O time complexities for various functions/algorithms

### 15-O
* Time complexities for an unsorted array
  * Accessing the nth element
  * Inserting at index n
  * Removing from index n
  * Searching for an element in array of size n
  * Setting value at index n

### 16-O
* Time complexities for a singly linked list
  * Accessing the nth element
  * Inserting after nth node
  * Removing nth elment
  * Searching for an element in array of size n
  * Setting value at index n

### 17-O
* Time complexities for a doubly linked list
  * Accessing the nth element
  * Inserting after nth node
  * Removing nth elment
  * Searching for an element in array of size n
  * Setting value at index n

### 18-O
* Time complexities for a Python 3 list
  * Accessing the nth element
  * Inserting at index n
  * Removing from index n
  * Searching for an element in array of size n
  * Setting value at index n

### 19-O
* Time complexities for a stack:
  * push
  * pop
  * search for element for size n

### 20-O
* Time complexities for a queue (with a pointer to head and tail):
  * push
  * pop
  * search for element for size n

### 21-O
* Time complexities for a hash table (using chaining for collisions):
  * Search for element (best case)
  * Search for element (worst case)
  * Insersion (best case)
  * Insertion (worst case)
  * Deletion (best case)
  * Deletion (worst case)

### 100-shell_sort.c
* Function implements the shell sort algorithm on an array of numbers

### 101-cocktail_sort_list.c, 101-O
* Function implements cocktail sort on a doubly linked list
* Complexity is similar to bubble sort (since it is essentially doing bubble sort from both directions)

### 102-counting_sort.c, 102-O
* Function implements counting sort over an array of integers
* Always O(n)

### 103-merge_sort.c, 103-O
* Function implements merge sort on an array of integers

### 104-heap_sort.c, 104-O
* Function implements heap sort on an array of integers

### 105-radix_sort.c, 105-O
* Function implements radix sort on an array of positive integers based on `LSD`
